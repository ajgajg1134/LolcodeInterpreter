#
global vars, expressionQueue
#TODO: Add a record for type checking
procedure main(args)
	vars := table("NOOB")
	write(parseLine("O RLY 1? YA RLY cool O RLY 0? YA RLY things NO WAI stuff OIC OIC\n"))
end

procedure executeBlock(block)
	write("Execing: " || block)
end

procedure parseLine(line)
	line ?
	{
		if ="I HAS A"
			then addVar(line) & return	
		p
	    if ="O RLY"
			then ifStmt(line) & return	
	}
end

procedure ifStmt(line)
	line ?
	{
		move(match("O RLY"))
	
		boolExpr := tab(upto('?'))
		move(1) #Get rid of '?'
		result := parseExpression(boolExpr || "\n")
		tab(find("YA RLY"))
		move(*"YA RLY")
		
		startBlockLocation := &pos
		winBlock := ""
		ifCounter := 0
		every wordLoc := upto(' \t\n') do
		{
			word := fullTrim(tab(wordLoc), ' \t\n')
			if word == "O"
				then ifCounter := ifCounter + 1
			if word == "NO" & ifCounter = 0
				then 
				{
					winBlock := line[startBlockLocation:(&pos-6)]
					elseBlockLoc := &pos
				}
			if word == "OIC"
				then
				{
					if ifCounter = 0
						then winBlock := line[startBlockLocation:(&pos-3)]
					if ifCounter > 0
						then ifCounter := ifCounter - 1
				}
		}

		write("Win: " || winBlock)
		
		if result = 1
			then
			{
				#TODO: Parse up string looking for ifs to allow nesting
				

				#if elseLoc := find("NO WAI")
				#	then codeBlock := tab(elseLoc)
				#	else codeBlock := tab(find("OIC"))
				#executeBlock(fullTrim(codeBlock, ' \t'))
			}
			else
			{
				#if elseLoc := find("NO WAI")
					#then
					#{
					#	tab(elseLoc)
					#	move(*"NO WAI")
					#	codeBlock := tab(find("OIC"))
					#}
														

			}
	}
end

procedure parseExpression(expr)
	whitespace := ' \t\n'
	expressionQueue := []
	expr ?
	{
		every loc := upto(whitespace) do
		{
			term := fullTrim(tab(loc), whitespace)
			if term ~== "OF" & term ~== "AN" 
				then 
				{
					put(expressionQueue, term)
				}
		}
	}
	return execExpression()
end

procedure execExpression()
	if *expressionQueue = 0
		then write("empty") & return

	node := pop(expressionQueue)
	write("Popped: " || node)
	if node[1] ? any(&digits)
		then return node
	
	if node == "SUM"
		then return execExpression() + execExpression()
	if node == "DIF"
		then return execExpression() - execExpression()
	if node == "PRODUKT"
		then return execExpression() * execExpression()
	if node == "QUOSHUNT"
		then return execExpression() / execExpression()
	if node == "MOD"
		then return execExpression() % execExpression()
	if node == "BIGGR"
		then
		{
			first := execExpression()
			second := execExpression()
			if first > second
				then return first
				else return second
		}
	if node == "SMALLR"
		then
		{
			first := execExpression()
			second := execExpression()
			if first > second
				then return second
				else return first
		}
	if node == "SAEM"
		then
		{
			if execExpression() = execExpression()
				then return 1
				else return 0
		}
	if node == "DIFFRINT"
		then
		{
			if execExpression() = execExpression()
				then return 0
				else return 1
		}

	return vars[node]
end

procedure addVar(line)
	whitespace := ' \t\n' 
	line ?
	{
		move(match("I HAS A"))
		varName := tab(upto(whitespace)) | tab(0)
		vars[varName] := "NOOB" #TODO: implement types
		write("varName: " || varName)	
		if findLoc := find("ITZ")
			then 
			{
				move(5)
				vars[varName] := line[&pos:*line+1] 
			}
	}
end

procedure fullTrim(str, chars)
	return reverse(trim(reverse(trim(str, chars)), chars))
end
